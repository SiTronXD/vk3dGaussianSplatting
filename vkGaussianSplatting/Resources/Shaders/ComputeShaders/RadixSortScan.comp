#version 450

#extension GL_GOOGLE_include_directive: require
#extension GL_KHR_shader_subgroup_arithmetic: require

#include "../Common/CommonRadix.glsl"

// Receive work group size as a specialization constant
layout(constant_id = 0) const uint WORK_GROUP_SIZE = 512u;

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// SBO
layout(binding = 0) buffer InputOutputBuffer
{
	uvec4 data[];
} inputOutputBuffer;

// Push constant
layout(push_constant) uniform PushConstantData
{
	uvec4 data; // uvec4(numSortElements, shiftBits, numCountWorkGroups, numReducedWorkGroups)
} pc;

// Shared memory (1024 * 16 = 16384 bytes are guaranteed to be available in Vulkan)
shared uint loadedElements[WORK_GROUP_SIZE];
shared uint distributeLastOffset;

void main()
{
	uint localIndex = gl_LocalInvocationID.x;
	uint numScanElements = pc.data.w;
	uint numIterations = (numScanElements + WORK_GROUP_SIZE - 1u) / WORK_GROUP_SIZE;

	uint highestOffset = 0u;
	for(uint i = 0u; i < numIterations; ++i)
	{
		// Load
		uint loadIndex = i * WORK_GROUP_SIZE + localIndex;
		uint loadedElement = 
			loadIndex < numScanElements ? 
			inputOutputBuffer.data[loadIndex].x : 
			0u;
		barrier();

		// Prefix sum
		uint newSum;
		{
			newSum = subgroupExclusiveAdd(loadedElement);

			if((localIndex + 1u) % gl_SubgroupSize == 0)
				loadedElements[localIndex / gl_SubgroupSize] = newSum + loadedElement;
			barrier();
			uint numIt = localIndex / gl_SubgroupSize;
			for(uint j = 0; j < numIt; ++j)
			{
				newSum += loadedElements[j];
			}
			newSum += highestOffset;
		}

		// Write
		if(loadIndex < numScanElements)
			inputOutputBuffer.data[loadIndex].x = newSum;

		// TODO: clean this up.
		// Synchronizing this way is necessary only because the number of 
		// reduce work groups can be larger than a work group size.
		if(localIndex == WORK_GROUP_SIZE - 1u) 
		{
			distributeLastOffset = newSum;
		}
		barrier();
		highestOffset = distributeLastOffset;
		barrier();
	}
}