#version 450

#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_shader_explicit_arithmetic_types_int64: require

#include "../Common/CommonRadix.glsl"

// Receive work group size as a specialization constant
layout(constant_id = 0) const uint WORK_GROUP_SIZE = 512u;

layout (local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// SBO
layout(binding = 0) buffer SumTableBuffer
{
	uvec4 buckets[];
} sumTable;

// SBO
layout(binding = 1) buffer ReduceBuffer
{
	uvec4 data[];
} reduce;

// Push constant
layout(push_constant) uniform PushConstantData
{
	uvec4 data; // uvec4(numSortElements, shiftBits, numCountWorkGroups, 0)
} pc;

void main()
{
	uint groupIndex = gl_WorkGroupID.x;
	uint localIndex = gl_LocalInvocationID.x;
	uint numCountWorkGroups = pc.data.z;
	uint numReduceGroupPerBin = gl_NumWorkGroups.x / BIN_COUNT;

	uint binId = groupIndex / numReduceGroupPerBin;
	uint binOffset = binId * numCountWorkGroups;

	uint baseIndex = (groupIndex % numReduceGroupPerBin) * WORK_GROUP_SIZE;
	//uint dataIndex = baseIndex + localIndex;
	//uint loadedValue = dataIndex < numCountWorkGroups ? sumTable.buckets[binOffset + dataIndex].x : 0u;

	// TODO: Replace with sum from shared memory or subgroups
	uint sum = 0u;
	for(uint i = 0; i < WORK_GROUP_SIZE; ++i)
	{
		uint dataIndex = baseIndex + i;
		sum += dataIndex < numCountWorkGroups ? sumTable.buckets[binOffset + dataIndex].x : 0u;
	}

	if(localIndex == 0)
		reduce.data[groupIndex].x = sum;

	// Assume this is incorrect for now
	/*uint localThreadIndex = gl_LocalInvocationID.x;
	uint threadGroupId = gl_WorkGroupID.x;

	uint sum = 0;
	for(int i = 0; i < WORK_GROUP_SIZE; ++i)
	{
		sum += sumTable.buckets[i].x;
	}

	if(localThreadIndex == 0)
	{
		reduce.data[threadGroupId].x = sum;
	}*/
}