#version 450

#extension GL_GOOGLE_include_directive: require

#include "../Common/Common.glsl"
#include "../Common/GaussiansStructs.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

// SBO
layout(binding = 0) readonly buffer GaussiansBuffer
{
	GaussianData gaussians[];
} gaussiansBuffer;

// SBO
layout(binding = 1) readonly buffer GaussiansSortListBuffer
{
	GaussianSortData sortData[];
} listBuffer;

// SBO
layout(binding = 2) readonly buffer GaussiansRangesBuffer
{
	GaussianTileRangeData rangeData[];
} rangesBuffer;

// UBO
layout(binding = 3) readonly uniform CamUBO 
{
	mat4 viewMat;
	mat4 projMat;
} ubo;

layout (binding = 4, rgba8) uniform image2D swapchainImage;

// Push constant
layout(push_constant) uniform PushConstantData
{
	uvec4 resolution;
} pc;

void main()
{
	uvec2 threadIndex = gl_GlobalInvocationID.xy;
	uvec2 res = pc.resolution.xy;

	// Make sure compute work is within bounds
	if(threadIndex.x >= res.x || threadIndex.y >= res.y)
		return;

	// UVs
	float width = float(res.x);
	float height = float(res.y);
	float aspectRatio = width / height;
	vec2 uv = (vec2(threadIndex) / vec2(res.xy)) * 2.0 - vec2(1.0);
	uv.x *= aspectRatio;

	vec3 color = vec3(0.0f);
	float Ti = 1.0f;

	const mat4 viewMat = ubo.viewMat;
	
	int gridWidth = (int(res.x) + TILE_SIZE - 1) / TILE_SIZE;
	uvec2 tilePos = threadIndex / uvec2(TILE_SIZE);
	uint tileIndex = tilePos.y * uint(gridWidth) + tilePos.x;
	uvec2 tileRange = rangesBuffer.rangeData[tileIndex].range.xy;

	// Loop through gaussians and render them
	for(uint i = tileRange.x; i < tileRange.y; ++i)
	{
		uint gaussianIndex = listBuffer.sortData[i].data.z;

		// Gaussian	data
		vec4 gColorAlpha = gaussiansBuffer.gaussians[gaussianIndex].color.xyzw;
		float gAlpha = gColorAlpha.w;
		vec3 gColor = gColorAlpha.xyz;
		vec3 gScale = gaussiansBuffer.gaussians[gaussianIndex].scale.xyz;
		vec4 gRot = gaussiansBuffer.gaussians[gaussianIndex].rot.xyzw;
		vec3 gCov = gaussiansBuffer.gaussians[gaussianIndex].covariance.xyz;
		vec3 gPosW = gaussiansBuffer.gaussians[gaussianIndex].position.xyz;
		vec4 gPosV = viewMat * vec4(gPosW, 1.0f);

		{
			float det = (gCov.x * gCov.z - gCov.y * gCov.y);

			if(det != 0.0f)
			{
				float det_inv = 1.f / det;
				vec3 covInv = vec3(gCov.z * det_inv, -gCov.y * det_inv, gCov.x * det_inv);
			
				// Screen space position
				vec4 gaussianPosScreen = getScreenSpacePosition(width, height, gPosV, ubo.projMat);
				
				// x^T * Sigma^(-1) * x
				vec2 evalX = gaussianPosScreen.xy - vec2(threadIndex);
				evalX.y = -evalX.y;

				// exp(-0.5f * x^T * Sigma^(-1) * x)
				float f = -0.5f * (covInv.x * evalX.x * evalX.x + covInv.z * evalX.y * evalX.y) - covInv.y * evalX.x * evalX.y;
				float alpha = gAlpha * exp(f);

				// Important for precision
				if(f > 0.0f || alpha < 1.0f / 255.0f)
					continue;
				
				// Apply gaussian
				color += Ti * alpha * gColor;

				float nextT = Ti * (1.0f - alpha);

				// Important for precision
				if(nextT < 0.0001f) 
					break;
			
				Ti = nextT;
			}
		}
	}

	// Write color
	color = clamp(color, vec3(0.0f), vec3(1.0f));
	imageStore(swapchainImage, ivec2(threadIndex), vec4(color, 1.0f));
}