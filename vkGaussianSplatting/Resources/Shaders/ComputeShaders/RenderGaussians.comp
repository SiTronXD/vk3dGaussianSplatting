#version 450

#extension GL_GOOGLE_include_directive: require

#include "../Common/Common.glsl"
#include "../Common/GaussiansStructs.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

// SBO
layout(binding = 0) readonly buffer GaussiansBuffer
{
	GaussianData gaussians[];
} gaussiansBuffer;

// SBO
layout(binding = 1) buffer GaussiansSortListBuffer
{
	GaussianSortData sortData[];
} listBuffer;

// SBO
layout(binding = 2) buffer GaussiansCullDataBuffer
{
	GaussianCullData data;
} cullData;

// UBO
layout(binding = 3) uniform CamUBO 
{
	mat4 viewMat;
	mat4 projMat;
} ubo;

layout (binding = 4, rgba8) uniform image2D swapchainImage;

// Push constant
layout(push_constant) uniform PushConstantData
{
	uvec4 resolution;
} pc;

void main()
{
	uvec2 threadIndex = gl_GlobalInvocationID.xy;
	uvec2 res = pc.resolution.xy;

	// Make sure compute work is within bounds
	if(threadIndex.x >= res.x || threadIndex.y >= res.y)
		return;

	// UVs
	float width = float(res.x);
	float height = float(res.y);
	float aspectRatio = width / height;
	vec2 uv = (vec2(threadIndex) / vec2(res.xy)) * 2.0 - vec2(1.0);
	uv.x *= aspectRatio;

	vec3 color = vec3(0.0f);
	float Ti = 1.0f;

	const mat4 viewMat = ubo.viewMat;
	const uint numGaussians = cullData.data.numGaussiansToRender.x;

	// Loop through gaussians and render them
	for(int i = 0; i < numGaussians; ++i)
	{
		uint gaussianIndex = listBuffer.sortData[i].data.z;

		// Gaussian	data
		float gAlpha = 1.0f; // TODO: should be a property part of the gaussian buffer
		vec3 gColor = gaussiansBuffer.gaussians[gaussianIndex].color.xyz; // TODO: should eventually use SH
		vec3 gScale = gaussiansBuffer.gaussians[gaussianIndex].scale.xyz;
		vec3 gPosW = gaussiansBuffer.gaussians[gaussianIndex].position.xyz;
		vec4 gPosV = viewMat * vec4(gPosW, 1.0f);

		// "Frustum culling"
		//if(gPosV.z < 0.0f)
		{
			vec3 cov = getCovarianceMatrix(width, height, gScale, gPosV, viewMat);
			float det = (cov.x * cov.z - cov.y * cov.y);

			if(det != 0.0f)
			{
				float det_inv = 1.f / det;
				vec3 covInv = vec3(cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv);
			
				// Screen space position
				vec4 gaussianPosScreen = getScreenSpacePosition(width, height, gPosV, ubo.projMat);
				
				// x^T * Sigma^(-1) * x
				vec2 evalX = gaussianPosScreen.xy - vec2(threadIndex);
				evalX.y = -evalX.y;

				// exp(-0.5f * x^T * Sigma^(-1) * x)
				float f = -0.5f * (covInv.x * evalX.x * evalX.x + covInv.z * evalX.y * evalX.y) - covInv.y * evalX.x * evalX.y;
				float alpha = gAlpha * exp(f);
				float nextT = Ti * (1.0f - alpha);
			
				// Apply gaussian
				color += Ti * alpha * gColor;
				Ti = nextT;
			}
		}
	}

	// Write color
	color = clamp(color, vec3(0.0f), vec3(1.0f));
	imageStore(swapchainImage, ivec2(threadIndex), vec4(color, 1.0f));
}