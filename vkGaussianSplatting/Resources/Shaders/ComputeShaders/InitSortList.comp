#version 450

#extension GL_GOOGLE_include_directive: require

#include "../Common/Common.glsl"
#include "../Common/GaussiansStructs.glsl"

#define LOCAL_SIZE 32

layout (local_size_x = LOCAL_SIZE, local_size_y = 1) in;

// UBO
layout(binding = 0) uniform CamUBO 
{
	mat4 viewMat;
	mat4 projMat;
} ubo;

// SBO
layout(binding = 1) readonly buffer GaussiansBuffer
{
	GaussianData gaussians[];
} gaussiansBuffer;

// SBO
layout(binding = 2) buffer GaussiansSortListBuffer
{
	GaussianSortData sortData[];
} listBuffer;

// SBO
layout(binding = 3) buffer GaussiansCullDataBuffer
{
	GaussianCullData data;
} cullData;

// Push constant
layout(push_constant) uniform PushConstantData
{
	vec4 clipPlanes; // vec4(nearPlane, farPlane, numGaussians, 0)
	uvec4 resolution; // uvec4(width, height, 0, 0)
} pc;

// Get extents uvec4(minX, minY, maxX, maxY), including min, excluding max
// (to avoid adding gaussians beyond screen edges)
uvec4 getGaussianTileExtents(uint threadIndex, vec4 gPosV, ivec2 gridSize)
{
	const float width = float(pc.resolution.x);
	const float height = float(pc.resolution.y);
	vec3 cov = getCovarianceMatrix(
		width, 
		height, 
		gaussiansBuffer.gaussians[threadIndex].scale.xyz, 
		gaussiansBuffer.gaussians[threadIndex].rot.xyzw,
		gPosV, 
		ubo.viewMat
	);
	float det = (cov.x * cov.z - cov.y * cov.y);

	// Eigenvalues of covariance matrix corresponds to the gaussian's extents.
	// lambda = m +- sqrt(m^2 - det)
	float m = (cov.x + cov.z) * 0.5f;
	float lambda0 = m + sqrt(max(m * m - det, 0.0f));
	float lambda1 = m - sqrt(max(m * m - det, 0.0f));
	float radius = ceil(3.0f * sqrt(max(lambda0, lambda1)));

	// Screen space position
	vec4 screenSpacePos = getScreenSpacePosition(width, height, gPosV, ubo.projMat);
	uvec4 gExtents = uvec4(
		clamp(int((screenSpacePos.x - radius) / TILE_SIZE), 0, gridSize.x), 
		clamp(int((screenSpacePos.y - radius) / TILE_SIZE), 0, gridSize.y),
		clamp(int((screenSpacePos.x + radius) / TILE_SIZE) + 1, 0, gridSize.x), 
		clamp(int((screenSpacePos.y + radius) / TILE_SIZE) + 1, 0, gridSize.y)
	);

	return gExtents;
}

uint getDepthKey(float viewSpacePosZ)
{
	const float nearPlane = pc.clipPlanes.x;
	const float farPlane = pc.clipPlanes.y;

	// Normalized depth
	float normalizedDepth = (-viewSpacePosZ - nearPlane) / (farPlane - nearPlane);
	normalizedDepth = clamp(normalizedDepth, 0.0f, 1.0f);

	return uint(normalizedDepth * float(MAX_UINT32));
}

void main()
{
	uint threadIndex = gl_GlobalInvocationID.x;
	uint numGaussians = uint(pc.clipPlanes.z + 0.5f);
	
	// Make sure compute work is within bounds
	if(threadIndex >= numGaussians) 
		return;

	vec4 viewSpacePos = ubo.viewMat * vec4(gaussiansBuffer.gaussians[threadIndex].position.xyz, 1.0f);
	/*vec4 ndcPos = ubo.projMat * viewSpacePos;
	ndcPos.xyz /= ndcPos.w;*/

	// "Frustum culling"
	if(-viewSpacePos.z <= pc.clipPlanes.x /*|| abs(ndcPos.x) > 1.3f || abs(ndcPos.y) > 1.3f*/)
		return;

	// Depth key
	uint depthKey = getDepthKey(viewSpacePos.z);

	// Extents
	const ivec2 gridSize = ivec2(
		(int(pc.resolution.x) + TILE_SIZE - 1) / TILE_SIZE,
		(int(pc.resolution.y) + TILE_SIZE - 1) / TILE_SIZE
	);
	uvec4 gExtents = getGaussianTileExtents(threadIndex, viewSpacePos, gridSize);
	
	// Add sort element per gaussian per overlapped tile
	//for(uint y = gExtents.y; y < gExtents.w; ++y) // TODO: uncomment after sorting is implemented
	{
		//for(uint x = gExtents.x; x < gExtents.z; ++x) // TODO: uncomment after sorting is implemented
		{
			// Tile key
			uint tileKey = 0;//y * gridSize.x + x; // TODO: uncomment after sorting is implemented
			depthKey = uint(abs(sin(threadIndex * 1235.344) * 212334.12)); // TODO: remove after sorting is implemented
			//tileKey = uint(abs(sin(threadIndex * 15.34) * 2124.12)); // TODO: remove after sorting is implemented

			// Add gaussian to list
			uint id = atomicAdd(cullData.data.numGaussiansToRender.x, 1u);
			if(id < cullData.data.numGaussiansToRender.y) // Temporary solution to avoid overflow
			{
				listBuffer.sortData[id].data.x = tileKey;
				listBuffer.sortData[id].data.y = depthKey;
				listBuffer.sortData[id].data.z = threadIndex;
			}
		}
	}
}