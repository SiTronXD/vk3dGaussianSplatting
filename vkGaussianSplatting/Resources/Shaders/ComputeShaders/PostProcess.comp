#version 450

#extension GL_GOOGLE_include_directive: require

#include "../Common/ColorTransformations.glsl"

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0, rgba16f) uniform readonly image2D hdrImage;
layout (binding = 1, rgba8) uniform image2D swapchainImage;

layout(push_constant) uniform PushConstantData
{
	//uvec4 resolution;
	mat4x4 viewMat;
	mat4x4 projMat;
} pc;

void main()
{
	uvec2 index = gl_GlobalInvocationID.xy;

	uvec2 res = uvec2(1280, 720);

	// Make sure compute work is within bounds
	if(index.x >= res.x || index.y >= res.y)
		return;

	// UVs
	float width = float(res.x);
	float height = float(res.y);
	vec2 uv = (vec2(index) / vec2(res.xy)) * 2.0 - vec2(1.0);
	uv.x *= width / height;

	vec3 color = vec3(0.0f);

	// Output 3D scene, for temporary debugging
	color = imageLoad(hdrImage, ivec2(index)).rgb;
	color = max(color, vec3(0.0f));
	color *= 0.3f;

	// Gaussian	
	vec3 gaussianPos = vec3(0.0f, 0.0f, 0.0f);
	vec4 gaussianPosView = pc.viewMat * vec4(gaussianPos, 1.0f);

	// "Frustum culling"
	if(gaussianPosView.z < 0.0f)
	{
		vec4 gaussianPosScreen = pc.projMat * gaussianPosView;
		gaussianPosScreen.xyz /= gaussianPosScreen.w;
		gaussianPosScreen.y = -gaussianPosScreen.y;
		gaussianPosScreen.xy = (gaussianPosScreen.xy + vec2(1.0f)) * 0.5f;
		gaussianPosScreen.xy *= vec2(width, height);

		mat3x3 rotMat = mat3x3(	1.0f, 0.0f, 0.0f,
								0.0f, 1.0f, 0.0f,
								0.0f, 0.0f, 1.0f);
		mat3x3 scaleMat = mat3x3(1.0f, 0.0f, 0.0f,
								 0.0f, 2.0f, 0.0f,
								 0.0f, 0.0f, 3.0f);
		mat3x3 sigma = rotMat * scaleMat * transpose(scaleMat) * transpose(rotMat);

		// Gaussian view space position
		vec4 gPosV = pc.viewMat * vec4(gaussianPos, 1.0f);
		mat3x3 W = mat3x3(	pc.viewMat[0][0], pc.viewMat[0][1], pc.viewMat[0][2],
							pc.viewMat[1][0], pc.viewMat[1][1], pc.viewMat[1][2],
							pc.viewMat[2][0], pc.viewMat[2][1], pc.viewMat[2][2]);
	
		float tanFovX = tan(3.1415f * 0.5f);
		float tanFovY = tanFovX;
		float focalX = width / (2.0f * tanFovX);
		float focalY = height / (2.0f * tanFovY);
		mat3x3 J = mat3x3(	focalX / gPosV.z, 0.0f, -(focalX * gPosV.x) / (gPosV.z * gPosV.z),
							0.0f, focalY / gPosV.z, -(focalY * gPosV.y) / (gPosV.z * gPosV.z),
							0.0f, 0.0f, 0.0f);
		mat3x3 sigmaPrime = J * W * sigma * transpose(W) * transpose(J);

		vec2 d = gaussianPosScreen.xy - vec2(index);
		//float f = dot(gaussianPos, inverse(sigmaPrime) * gaussianPos);

		vec3 cov = vec3(sigmaPrime[0][0], sigmaPrime[0][1], sigmaPrime[1][1]);
		float det = (cov.x * cov.z - cov.y * cov.y);

		if(det != 0.0f)
		{
			float det_inv = 1.f / det;
			vec3 conO = vec3(cov.z * det_inv, -cov.y * det_inv, cov.x * det_inv);
			float f = -0.5f * (conO.x * d.x * d.x + conO.z * d.y * d.y) - conO.y * d.x * d.y;
			float gaussian = exp(-0.5 * f);
			//color += gaussian * vec3(0.0f, 1.0f, 1.0f);

			color += length(d) < 20.0f ? vec3(1.0f) : vec3(0.0f);
		}
	}

	// Write color
	color = clamp(color, vec3(0.0f), vec3(1.0f));
	imageStore(swapchainImage, ivec2(index), vec4(color, 1.0f));
}